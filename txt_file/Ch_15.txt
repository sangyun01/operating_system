* Address Translation

** memory virtualizing
memory virtualizing은 illusion 기반으로 동작하며, 이때 LDE(limited direct execution)에 따라 동작한다.
따라서 이는 HW 차원에서 발생을 하게 된다.
-> SW보다 safe & fast, but 전부 HW 차원에서 발생은 하지 않는다.
virtual address에서 physical address로 transform(mapping)이 되기 위해서는 특정한 정보들이 필요하며, 이는 OS에서 제공한다.

virtual address는 0KB에서 시작하는 반면, main memory 즉 physical address에서는 다른 주소이므로 따라서 mapping을 통해 translation을 한다.
주로 main memory의 0번지 주소에는 중요한 주소가 있기 때문이다.
따라서 이를 파악하기 위해서 base와 bound(limit)을 reg에 저장함으로써 확인이 가능하다.
base의 경우에는 physical memory에서, address space에서 bound 즉 limit의 값을 이용한다.

이때 HW로 구현을 하였기에 Dynamic Relocation이라 하며, 만약 SW로 구현을 하였다면 Statice Relocation이라한다.
따라서 base register를 이용하여, Translation을 하는 방법으로는
physical address = base + virtual address를 통해 가능하며
virtual address의 값이 0이상 bound보다 작은 값을 가지는 것을 확인해야한다.

ex) CODE
fetch inst addr -> 128, BASE at 32KB
즉 CODE이므로 BASE + inst addr = 32896
exec inst addr -> 15KB, BASE at 32KB
BASE + inst addr = 47KB이다.

** OS Issue for memory virtualizing
4 critical junctures
- when a process starts running -> process가 시작하는 경우
실행이 시작되는 경우(생성이 아님) 사용되지 않는 공간에 대한 정보를 가진 free list에서 탐색을 하여 address space를 찾는다.
- when a process is terminated  -> process가 종료하는 경우
종료 후 반환을 하게 되는 경우, free list에서 update를 한다.
- when context switch occurs    -> context switch가 발생하는 경우
PCB를 이용하여 해당 base, bound의 정보를 저장 및 복원한다.
- when exception occurs         -> 예외처리가 발생하면 주로 terminated로 해결한다.

