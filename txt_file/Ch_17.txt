* Free-Space Manaement

** Splitting(분리하는 작업)
Finding the free chunk of memory that can satisfy the request and splitting it into twp
-> 즉 요구된 memory가 할당이 가능한 free chunk를 찾고, 넣기 위해서 splitting을 하는 작업이 필요하다.
ex) malloc(1)
before  => free list : head → addr:0 / len:10 → addr:20 / len:10 → NULL
after   => free list : head → addr:0 / len:10 → addr:21 / len:9 → NULL

** Coalescing(합치는 작업)
If a user requests memory that is bigger than free chunk size, the list will not find such a free chunk.
-> 가진 free chunk보다 더 큰 memory를 요청 받는다면, list에서 찾을 수 없다.
-> 따라서 coalescing 작업을 통해 free memory block을 merge하여 가능하도록 한다.
ex) malloc(20)
before  => free list : head → addr:10 / len:10 → addr:0 / len:10 → addr:20 / len:10 → NULL
-> malloc(20)이 불가하다. -> coalescing를 진행한다.
after   => free list : head → addr:0 / len:30 → NULL
-> malloc(20)이 가능하다.

이때 malloc()을 하게 되면 반환하는 값은 ptr이 가르키는 주소이며, 이떄 hptr도 같이 생성이 되며, 따라서 이 공간은 ptr 바로 위에 존재한다.
void free(void *ptr) {
    header_t *hptr = (header_t *)ptr - 1
}
hptr 즉 header는 최소한 size of allocated memory region을 가지고 있다.
또한 무결성 check를 위한 magic number도 가지고 있다. 이를 코드로 표현하면 아래와 같다.
typedef struct __header_t {
    int size;   // check the size       -> 4byte
    int magic;  // check the integrity  -> 4byte
} header_t

따라서 위의 코드를 기준으로 malloc(N)을 한다면 N + 8(size of header)를 가지게 된다.

allocator의 경우는 free list를 만들기 위해서 free list를 만든다면, 무한 재귀 호출이 된다.
-> free list node는 free block 내부에 직접 저장하며, 초기에 실행되면서 내부에 자동으로 생성이 된다.

Free list의 node code는 아래와 같다.
typedef struct __node_t {
    int size;
    struct __node_t *next;
} node_t
즉, linked list 구조로 이루어져 있으며
이때 만약 node_t *head = mmap(NULL, 4096,..)이라면 실제로는 header로 인하여 4096 - 8 = 4088만큼의 size를 가지게 된다.

allocation을 하게 된다면 malloc(100)을 순차적으로 3번 진행한다면 아래와 같은 순서로 사이즈가 정해진다.
4088 (4096 - 8) → 3980 (4088 - 108) → 3872 (4088 - 108 - 108) →  3764 (4088 - 108 - 108 - 108)
즉 3,764만큼의 free chunk를 최종적으로 가지고 있다.

이 상태에서 free를 하게 된다면 108만큼의 사이즈가 다시 반환이 되는 것이 아닌 100만 반환이 되며, 나머지 8은 free list의 node로 사용된다.
따라서 free list의 node로 인하여 연속된 free space이더라도 연속적으로 memory를 사용할수 없기에 coalescing의 과정이 필요하다.

** Managing Free Space
*** Best Fit
request보다 큰 free chunk를 모두 찾아서, 가능한 chunk 중 가장 작은 chunk를 선택한다.
-> 단점 : full search를 하면서 높은 비용이 발생한다.
-> 단점 : 작은 조각의 free spcae가 발생할 가능성이 매우 높다.

*** Worst Fit
request보다 큰 free chunk를 모두 찾아서, 가장 큰 chunk를 선택한다.
-> 단점 : full search를 하면서 높은 비용이 발생한다.

*** First Fit
앞에서부터 request보다 큰 chunk를 찾는다면 바로 선택한다.
-> 단점 : 앞쪽에 free chunk가 매우 많이 발생한다.

*** Next Fit
First Fit과 비슷하지만, 찾는 위치가 그만 두었던 위치에서 다시 시작하여, First Fit의 문제를 보완한다.

*** Segregated list
자주 쓰는 크기의 Size를 사전에 분리해두며, 따라서 Space를 너무 많게도, 적게도 아닌 적당히 분리를 해두어야한다.

*** Slab Allocator
memory page를 여러 개 묶어둔 하나의 unit으로, 자주 사용하는 object를 미리 할당해두며, 따라서 특정 type을 위한 Segregated list이다.

*** Binary Buddy Allocation
들어갈만한 공간이 나올 때까지 절반으로 split을 진행하며, 이는 buddy를 찾기 쉽기에 병합을 하는데 있어 이점을 가지는 것을 확인할 수 있다.

