# Free-Space Management

## Splitting (분리하는 작업)

요구된 memory 크기를 만족할 수 있는 free chunk를 찾은 뒤, 필요한 만큼만
사용하고 남는 공간을 잘라내(split) free list에 남겨둔다.

예시: `malloc(1)`

**Before**

    free list : head → addr:0 / len:10 → addr:20 / len:10 → NULL

**After**

    free list : head → addr:0 / len:10 → addr:21 / len:9 → NULL

------------------------------------------------------------------------

## Coalescing (합치는 작업)

사용자가 요청한 크기(request)가 free chunk들보다 큰 경우, free
list만으로는 만족할 공간을 못 찾는다.\
따라서 **인접한 free block들을 병합(coalesce)** 하여 큰 free block을
만든다.

예시: `malloc(20)`

**Before**

    free list : head → addr:10 / len:10 → addr:0 / len:10 → addr:20 / len:10 → NULL

이 상태에서는 20만큼 연속된 공간을 찾을 수 없음 → **coalescing 수행**

**After**

    free list : head → addr:0 / len:30 → NULL

------------------------------------------------------------------------

## Header 구조와 malloc / free 동작

``` c
typedef struct __header_t {
    int size;   // allocated memory size
    int magic;  // integrity check
} header_t;
```

`malloc(N)` → 실제 요구 공간 = **N + 8 bytes(header)**

### free() 시 동작

``` c
void free(void *ptr) {
    header_t *hptr = (header_t *)ptr - 1;
}
```

------------------------------------------------------------------------

## Free List의 node 구조

``` c
typedef struct __node_t {
    int size;
    struct __node_t *next;
} node_t;
```

예:\
`mmap(NULL, 4096, ...)` → header 8을 제외한 **4088 bytes free**

------------------------------------------------------------------------

## Allocation 예시

`malloc(100)` 3번 호출:

    4088 → 3980 → 3872 → 3764

free 시 실제 payload(100)만 반환되며 header(8)는 free list node로 사용됨
→\
따라서 free space가 연속이어도 바로 재사용 불가 → **coalescing 필요**

------------------------------------------------------------------------

## Managing Free Space

### Best Fit

-   request보다 **큰 free chunk 전체 조사**
-   그중 가장 작은 chunk 선택\
-   **단점:** full search 비용 큼, 작은 조각 많이 생김

### Worst Fit

-   request보다 큰 chunk 중 **가장 큰 chunk 선택**
-   단점: full search 비용 큼

### First Fit

-   앞에서부터 찾다가 처음 맞는 chunk 선택\
-   단점: 앞부분 free block 파편화 심함

### Next Fit

-   First Fit과 동일하나 **지난 위치부터 다시 검색**\
-   locality 개선

### Segregated List

-   자주 쓰는 size 구간을 미리 분리하여 저장

### Slab Allocator

-   자주 쓰는 object를 미리 page 단위로 할당\
-   특정 타입을 위한 segregated list

### Binary Buddy Allocation

-   공간을 절반씩 나누어 split\
-   buddy 계산이 쉬워 merge(coalesce)에 유리
