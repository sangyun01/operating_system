# Address Translation

## 1. Memory Virtualizing

Memory virtualizing은 **illusion 기반**으로 동작하며, 이때 **LDE(Limited
Direct Execution)** 원리에 따라 동작한다.\
따라서 이는 **HW 차원에서 수행되는 부분이 많으며**, SW보다
**안전(safe)** 하고 **빠르다(fast)**.\
그러나 모든 동작이 HW에서만 수행되는 것은 아니며, **OS가 제공하는 정보가
필요**하다.

Virtual address(VA)는 **항상 0KB에서 시작**하지만, physical
address(PA)는 메모리의 실제 위치를 따라 달라진다.\
따라서 VA → PA로 변환하기 위해서는 **mapping(translation)** 과정이
필요하며, 이때 OS는 base와 bound(limit) 값을 제공한다.

### Base & Bound Register

-   Base: 해당 프로세스의 physical memory 시작 주소\
-   Bound(limit): 해당 프로세스의 address space 크기\
-   Translation Rule:\
    \[ ext{Physical Address} = ext{Base} + ext{Virtual Address} \]\
-   Valid Check:\
    \[ 0 `\le     `{=tex}ext{Virtual Address} \< ext{Bound} \]

### Dynamic Relocation

-   HW 기반: **Dynamic Relocation**
-   SW 기반: **Static Relocation**

### Example

    CODE fetch inst addr -> 128
    BASE = 32KB

    Physical Address = 32KB + 128 = 32896

    EXEC inst addr -> 15KB
    Physical Address = 32KB + 15KB = 47KB

------------------------------------------------------------------------

## 2. OS Issues for Memory Virtualizing

### OS는 다음 4가지 시점에서 base & bound를 다룬다

### 1) When a process starts running

프로세스 실행 시(생성 X), OS는 **free list에서 적절한 address space**를
찾는다.

### 2) When a process is terminated

프로세스 종료 시, 사용하던 메모리를 **free list에 반환**하여
업데이트한다.

### 3) When a context switch occurs

PCB(Process Control Block)에 저장된\
`base`, `bound` 값을 **저장/복원**하여 다른 프로세스의 주소 공간으로
전환한다.

### 4) When an exception occurs

주소 오류 등 예외 발생 시, 대부분 프로세스를 **terminated** 방식으로
처리한다.

------------------------------------------------------------------------
