# Advanced Page Tables

## Paging: Linear Tables

32bit Address Space(AS)를 4KB 페이지로 나누고, Page Table Entry(PTE)가
4B라면:

-   Page Table Size = (2³² / 2¹²) × 2² = **4MB**

Page Table이 너무 크므로 Pages를 키우는 단순한 방법을 고려할 수 있다.

### Page Size 증가 예시

-   Page Size: 4KB → 16KB (2¹² → 2¹⁴)
-   Page Table Size = (2³² / 2¹⁴) × 2² = **1MB**

하지만 Page가 커지면 내부 단편화(internal fragmentation)가 증가해서
비효율적이다.

------------------------------------------------------------------------

## Hybrid Approach: Paging + Segmentation

Page Table을 Segment 단위로 나누어 CODE, HEAP, STACK 기반으로 구성.

  segVal   Content
  -------- ---------
  00       unused
  01       CODE
  10       HEAP
  11       STACK

하지만 세그먼트 크기가 크면 여전히 외부 단편화(external fragmentation)가
발생한다.

------------------------------------------------------------------------

## Multi-level Page Tables

Linear Page Table을 **tree 구조** 형태로 변환.

    Page Directory → Page Table → Physical Memory

-   PD(Page Directory): 어떤 Page Table을 쓸지 저장
-   PT(Page Table): VPN → PFN 매핑 저장
-   장점: 사용되지 않는 영역의 PT를 만들어두지 않아 **메모리 절약**
-   단점: 레벨이 깊어질수록 접근 시간 증가

------------------------------------------------------------------------

## Multi-level 예시 1: Single Level Paging

-   AS = 16KB = 2¹⁴\
-   Page Size = 64B = 2⁶\
    → Offset = 6bit, VPN = 14−6 = **8bit**

PTE 개수 = 2⁸\
각 PTE = 4B → Page Table Size = **1KB**

Page Table 한 페이지 크기(64B)에 들어갈 수 있는 엔트리 = 1KB / 64B =
**16 = 2⁴**

→ 따라서 **VPN(8bit)을 상위 4bit(PD index) + 하위 4bit(PT index)** 로
분할한다.

------------------------------------------------------------------------

## Multi-level 예시 2: 더 깊은 구조가 필요한 경우

-   AS = 30bit\
-   Page Size = 512B = 2⁹\
    → Offset = 9bit → VPN = 30 − 9 = **21bit**

PTE 크기 = 4B\
Page Table 한 페이지(512B)에 들어가는 엔트리 수 = 512 / 4 = **128 = 2⁷**

따라서: - 한 Page Table은 2⁷개의 index - 전체 VPN(21bit)을 커버하려면
PD가 2¹⁴ 필요 - 하지만 2¹⁴ 엔트리를 하나의 PD 페이지에 담을 수 없음

### 해결

**Page Directory를 2단계로 구성** - 상위 PD₁: 2⁷ index\
- 하위 PD₂: 2⁷ index\
→ 총 2⁷ × 2⁷ = 2¹⁴ 커버 가능

------------------------------------------------------------------------

## Inverted Page Table

전통적 Page Table은:

    VPN → PFN

Inverted Page Table은 반대로:

    PFN → (VPN, PID)

-   시스템 전체에 Page Table 1개만 존재\
-   프로세스별 page table이 아니라, **물리 프레임 중심 구조**
-   장점: 메모리 크게 절약\
-   단점: 역방향 검색 필요 → 해시 기반 구조(Hash Table) 사용

------------------------------------------------------------------------

# End of Document
