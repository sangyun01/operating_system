# LOCK

mutual exclusion을 위해 lock이 필요하다.  
즉 critical section은 **single atomic instruction**처럼 동작해야 하므로 HW & OS의 협력이 필요하다.

---

## LOCK - Basic Criteria

- **Mutual Exclusion**  
  Lock을 사용하는 가장 근본적인 이유.

- **Fairness**  
  특정 thread/process가 starvation되지 않아야 한다.

- **Performance**  
  멀티스레딩의 목적은 더 빠르게 실행하기 위함이므로, lock 사용 자체가 큰 오버헤드를 주면 안 된다.

---

## Disable Interrupt

가장 초기의 lock 방법으로, **물리적으로 interrupt를 disable**하여 atomic 구역을 보장한다.

### 문제점
- user-level app에 과도한 권한이 생김  
- multiprocessor 환경에서는 동작하지 않음  
- interrupt를 막으면 hardware signal 처리 누락 가능

---

## Test and Set

TestAndSet은 HW에서 atomic하게 구현됨.

```c
int TestAndSet(int *ptr, int new) {
    int old = *ptr;    // fetch old value at ptr
    *ptr = new;        // store 'new' into ptr
    return old;        // return the old value
}
```

이 연산은 **동시에/원자적으로** 일어난다.

### Spin Lock 형태

```c
void lock(lock_t *lock) {
    while (TestAndSet(&lock->flag, 1) == 1)
        ;   // spin-wait
}
```

- lock을 얻을 때까지 계속 확인(spinning)
- spinning 동안 CPU를 계속 점유 → 비효율적

### Compare and Swap(CAS)
TestAndSet보다 일반적으로 더 효율적이며, 불필요한 store 연산을 줄일 수 있다.

### 평가
- **Correctness**: Yes  
- **Fairness**: No  
- **Performance**: No  

---

## Fetch and Add (Ticket Lock)

```c
int FetchAndAdd(int *ptr) {
    int old = *ptr;
    *ptr = old + 1;
    return old;
}
```

ticket machine 방식으로 thread에게 ticket을 순서대로 배정한다.

### 장점
- 공정성(Fairness) 보장  
- starvation 없음

### 단점
- 여전히 spinning이 발생하여 CPU 낭비

### 평가
- **Correctness**: Yes  
- **Fairness**: Yes  
- **Performance**: No  

---

## Just Yield

spinning 중인 thread가 CPU를 yield() 사용해 다른 thread에게 양보.

```c
void lock() {
    while (TestAndSet(&flag, 1) == 1)
        yield();    // give up the CPU
}
```

spin-only 방식보다 훨씬 효율적이지만, 여전히 완전한 blocking 방식은 아니다.

---

## Using Queue (Park / Unpark 기반 Blocking Lock)

spinning을 최소화하기 위해 lock을 기다리는 thread를 **queue에 넣고** 실행을 park()로 중단한 뒤, unlock 시 unpark()로 깨운다.

### Lock 구조체

```c
typedef struct __lock_t {
    int flag;
    int guard;
    queue_t *q;
} lock_t;
```

`guard`는 queue 자체를 보호하는 데 사용되는 추가적인 lock(2nd flag).

---

## Lock 함수

```c
void lock(lock_t *m) {
    while (TestAndSet(&m->guard, 1) == 1)
        ;   // acquire guard lock by spinning

    if (m->flag == 0) {
        m->flag = 1;      // lock is acquired
        m->guard = 0;
    } else {
        queue_add(m->q, gettid());
        m->guard = 0;
        park();           // sleep until unparked
    }
}
```

---

## Unlock 함수

```c
void unlock(lock_t *m) {
    while (TestAndSet(&m->guard, 1) == 1)
        ;   // acquire guard lock by spinning

    if (queue_empty(m->q)) {
        m->flag = 0;      // no one waiting
    } else {
        unpark(queue_remove(m->q)); // wake next thread
    }

    m->guard = 0;
}
```

### 특징
- guard는 queue 접근 시 race를 막기 위한 작은 spin lock
- spinning은 최소화되며 대부분의 thread는 sleep 상태로 전환
- OS 기반 blocking lock 방식 → 효율적이고 공정함
