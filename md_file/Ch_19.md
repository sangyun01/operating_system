# TLB (Translation Lookaside Buffer)

TLB는 **Processor 위에 있는 하드웨어 기반 Cache**로서, Page Table 접근을 줄여 주소 변환 속도를 향상시키는 장치이다.

------------------------------------------------------------------------

## TLB 동작 개요

TLB는 최근 사용한 **VPN → PFN 매핑을 캐싱**한다.

-   **TLB Hit**: 메모리 접근 없이 바로 PFN을 얻어 주소 변환 수행
-   **TLB Miss**: Page Table을 메모리에서 읽어 TLB에 삽입 후 다시
    instruction 재실행

------------------------------------------------------------------------

## TLB 기본 알고리즘

    1:  VPN = (VirtualAddress & VPN_MASK) >> SHIFT
    2:  (Success , TlbEntry) = TLB_Lookup(VPN)
    3:      if(Success == TRUE){        // TLB Hit
    4:          if(CanAccess(TlbEntry.ProtectBit) == True ){
    5:              offset = VirtualAddress & OFFSET_MASK
    6:              PhysAddr = (TlbEntry.PFN << SHIFT) | offset
    7:              AccessMemory( PhysAddr )
    8:          }else
    9:              RaiseException(PROTECTION_ERROR)
    10:     }else{                       // TLB Miss
    11:         PTEAddr = PTBR + (VPN * sizeof(PTE))
    12:         PTE = AccessMemory(PTEAddr)
    13:         if(PTE.Valid == False)
    14:             RaiseException (SEGFAULT)
    15:         else{
    16:             TLB_Insert( VPN , PTE.PFN , PTE.ProtectBits)
    17:             RetryInstruction()
    18:         }
    19:     }

------------------------------------------------------------------------

## 예시: Spatial Locality와 TLB Hit 증가

    int sum = 0;
    for (i = 0; i < 10; i++) {
        sum += a[i];
    }

`a[]` 배열이 다음과 같이 페이지에 배치되었다고 하자:

-   VPN = 06: a\[0\], a\[1\], a\[2\]
-   VPN = 07: a\[3\], a\[4\], a\[5\], a\[6\]
-   VPN = 08: a\[7\], a\[8\], a\[9\]

Miss는 **a\[0\], a\[3\], a\[7\]**에서 발생 → 총 3회
나머지는 모두 Hit → **10회 → 3회 memory access로 감소**

------------------------------------------------------------------------

# Who Handles the TLB Miss?

  Architecture   TLB Miss 처리 방식
  -------------- --------------------
  **CISC**       HW managed TLB
  **RISC**       SW managed TLB

------------------------------------------------------------------------

# TLB Entry 구조

일반적으로 다음과 같은 형태:

| VPN | PFN | 기타 |

------------------------------------------------------------------------

# TLB Issue: Context Switching

프로세스 A/B는 서로 **다른 Address Space**를 가진다.

따라서 동일한 VPN이라도 다른 PFN으로 매핑될 수 있다.

→ 이를 해결하기 위해 **ASID(Address Space ID)**를 추가하여 프로세스를
구분한다.

------------------------------------------------------------------------

# Code Sharing

코드는 공유하지만 Heap/Stack은 개별적일 경우:

-   공유 Code: PFN 동일
-   VPN이 달라도 문제 없음

------------------------------------------------------------------------

# TLB Replacement Policy

TLB 크기가 작기 때문에 교체 알고리즘 필요 → 보통 **LRU** 사용.

------------------------------------------------------------------------

## LRU 예제

Page Frame: 3개
Reference:

    7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1

Page Frame 변화:

| PF      |   1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
|---------|-----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
| Row     |   7 |  0 |  1 |  2 |  0 |  3 |  0 |  4 |  2 |  3 |  0 |  3 |  2 |  1 |  2 |  0 |  1 |
| PF0     |   7 |  7 |  7 |  2 |  2 |  2 |  2 |  4 |  4 |  4 |  0 |  0 |  0 |  1 |  1 |  1 |  1 |
| PF1     |   X |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  3 |  3 |  3 |  3 |  3 |  3 |  0 |  0 |
| PF2     |   X |  X |  1 |  1 |  1 |  3 |  3 |  3 |  2 |  2 |  2 |  2 |  2 |  2 |  2 |  2 |  2 |

------------------------------------------------------------------------

# End of Document
