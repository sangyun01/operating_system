# Concurrency

## Thread

**Thread**는 *single running process* 내부에서 실행 단위를 추상화한 개념이다.

### Multi-threaded Program

- **Multiple points of execution**  
  하나의 프로세스를 여러 실행 단위로 나누어 여러 지점에서 동시에 실행될 수 있다.

- **Multiple Program Counters**  
  각 스레드는 **자신만의 PC**와 **자신만의 Stack**을 가진다.

- **Shared Address Space**  
  스레드는 하나의 프로세스 내부에서 실행되므로 **address space를 공유**한다.  
  → 즉 **code, global, heap은 공유**, **stack은 분리**된다.

### Thread Context Switch

스레드 간 전환 시에도 **Context Switch**가 발생한다.

- 스레드는 고유한 **TCB(Thread Control Block)**을 가진다.
- 전환 시 **state save / restore**가 수행된다.
- 프로세스 내부에서 작업하므로 비용은 프로세스 간 전환보다 일반적으로 더 작다.

---

## Why Using Threads?

### Single-threaded Program
- 구조가 단순하여 구현이 쉽다.
- 그러나 전체 프로그램이 **하나의 흐름**으로만 동작하므로 **느리다**.

### Multi-threaded Program

- **동시성 증가** → 성능 향상 가능성이 높다.
- CPU-bound + IO-bound 상황에서 특히 유리.
- **Parallelization 가능**
- **I/O 지연 문제 완화**  
  예: 이메일 작성 중에도 파일 첨부(느린 IO)가 동시에 처리됨.

---

## 문제점: Race Condition

멀티스레드 환경에서는 **Race Condition**이 발생할 수 있다.  
→ 정답이 여러 개가 될 수 있는 *비결정성(Non-determinism)* 문제가 생김.

### 예시

| Thread1 | Thread2 | PC | %eax | Counter |
|--------|---------|----|-------|---------|
| mov    |         |105 | 50    | 50      |
| add    |         |108 | 51    | 50      |
|        | mov     |105 | 50    | 50      |
|        | add     |108 | 51    | 50      |
|        | mov     |113 | 51    | 51      |
| restore|         |108 | 51    | 50      |
| mov    |         |113 | 51    | 51      |

→ 최종 결과는 **51 또는 52**, 즉 *결정되지 않음*.

---

## Solution: Critical Section & Mutual Exclusion

Race Condition의 근본적인 해결책은 **Critical Section 보호**이다.

### No Mutual Exclusion

- 단순 플래그를 이용한 software lock 방식은  
  interrupt 또는 scheduling으로 인해 mutual exclusion을 보장하지 못한다.

### Spin-waiting

- 소프트웨어 레벨에서 lock을 구현하면  
  스레드가 계속 기다리며 CPU 자원을 낭비한다.

### 따라서 HW + SW 방식의 Lock이 필요

- 실제 OS 및 CPU는 **HW primitive(test-and-set, compare-and-swap 등)**을 제공한다.
- SW는 이를 기반으로 lock을 추상화하여 mutual exclusion을 구현한다.
- HW primitive는 atomic 연산이기 때문에 interrupt 중단 없이 mutual exclusion을 보장한다.
