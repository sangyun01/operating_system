OS(Operating System) - HW와 APP 사이에서 작동한다.

** CPU virtualizing
    - OS can promote the illusion that many virtual CPUs exist : CPU가 여러개로 가상으로 존재하도록 보이게 한다
    - HOW? Using "Time Sharing" method - 짧은 순간에 동작하여, 사람이 느끼기에 동시에 작동한다.
    - time과 order의 결정 - Scheduling policy에 따라 정해지며, 이때 시간에 따라 나누어 쓰기에, Performance 저하가 발생하게 된다.

** Process : Running Program
    Memory      : Instructions, Data Section
    Registers   : PC, sp, GPIO

** Process API
These APIs are available on any modern OS // 대부분의 API는 이름은 다를 수 있지만, 기능적으로 차이는 없느 5가지 기능을 가지고 있다.
    - Create
    - Destroy
    - Wait
    - Miscellaneous Control
    - Status

이 중 "Create" Process에 대해서 자세히 본다.
Order : Load -> Stack -> Heap -> Other initialization tasks -> Start Program
    1. Load     : Processor는 Disk에 직접적으로 접근이 불가능하다.
                -> 따라서 Disk -> Memory로 Code와 Data를 포함한 executable format으로 올라간다.
                이때 모든 file이 아닌 실행을 하는데 있어 필요한 일부만 올라간다. -> lazily : 전부 올라가게 되면 실행을 하는데 있어 너무 오래걸림.
    2. Stack    : Program(Process)가 끝나면 사라지는 local variable, function parameters들을 Stack을 이용하여 사용한다.
                -> Stack이 할당되면서, 초기화된 argc, argv의 배열을 main ftn이 작동될 때 인자로 사용한다.
    3. Heap     : Dynamically data를 이용할 때, 즉 사용자가 얼마나 공간을 사용할지 모를 때 사용을 한다.
                -> malloc() 함수를 이용하여 공간을 할당하고, 다 사용을 한 후에는 free() 함수를 호출하여, 이 공간을 자유롭게 사용가능하도록 둔다.
    4. Other initialization tasks
                -> I/O request와 같이 나머지 작업들을 수행한다. 이때 각 process는 input, output, error의 총 3개의 desciptors를 가진다.
    5. Start program : Stack에서 초기화한 argc, argv를 이용하여 main function을 실행한다.

program은 실행되기 전에 Disk에 위치해 있으며, 이때 실행가능한 file 형태로 존재한다.(executable format)
    -> Program을 실행하면 Memory에 있는 code, data, heap stack을 CPU에 Register 형태로 이동하게 된다.

Create
Disk -> Memory -> CPU
Disk : Code와 Data가 실행 가능한 형태(executable format)으로 Load 전에 존재한다. ex) SSD
-> Memory : Code와 Data가 Memory로 load된다.(when program execution)
-> Memory : Stack과 Heap이 생성된다.
-> 이후 Memory에 있던 값이 Fetch를 통해 CPU(Processor)의 Register에 저장된다.

** Process States
A process can be one of three states.
- Running   : A process is running on a processor
            -> Process가 실행되고 있는 상태   
- Ready     : A process is ready to run but for some reason the OS has chosen not to run
            -> 실행은 가능하지만, 실행은 하고 있지 않는 상태 (다른 Process에서 사용 중인 경우)
- Blocked   : A process has performed some kind of operation.
            -> ex) I/O request to a disk.
                    I/O request : CPU가 disk에 직접 접근이 불가하다.
                    -> disk에 있는 file이 memory로 올라와야 하므로 시간이 소요되므로, 이때 다른 process를 진행시켜 CPU의 활용을 증가
                    (없다면 CPU 자원 낭비)

Process State Transition
Running ↔ Ready     : Scheduler
Running → Blocked → Ready → Running
Running → Blocked   : I/O initiate
Blocked → Ready     : I/O done

** Data Structures
PCB(Process Control Block)
    - contains information about each process.
    - PID, PC, name, locate
    - Register Context : a set of registers that define the state of a process.

Process list
    Ready processes
    Blocked processes
    Current running process
